byte NUMBER0[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte NUMBER1[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,1,1,1,0,
  0,0,0,0,0,0,0,0,0,1,1,1,0,0,
  0,0,0,0,0,0,0,0,1,1,1,0,0,0
};
byte NUMBER2[] = {
  1,1,0,0,0,0,1,1,1,1,1,1,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,0,0,0,0,1,1
};
byte NUMBER3[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1
};
byte NUMBER4[] = {
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,1,1,1,1,1,1,1,1
};
byte NUMBER5[] = {
  1,1,1,1,1,1,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,1,1,1,1,1,1
};
byte NUMBER6[] = {
  1,1,1,1,1,1,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte NUMBER7[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,1,1
};
byte NUMBER8[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte NUMBER9[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,1,1,1,1,1,1
};

byte _[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
byte A[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,1,1,0,0,0,0,1,1,
  0,0,0,0,0,0,1,1,0,0,0,0,1,1,
  0,0,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte B[] = {
  0,0,1,1,1,0,0,0,0,1,1,1,0,0,
  0,1,1,0,1,1,0,0,0,1,0,1,1,0,
  1,1,0,0,0,1,1,1,1,0,0,0,1,1,
  1,0,0,0,0,0,1,1,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte C[] = {
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,1,0,1,1,1,1,1,1,1,1,1,1
};
byte D[] = {
  0,0,0,1,1,1,1,1,1,1,1,0,0,0,
  0,0,1,1,0,0,0,0,0,0,1,1,0,0,
  0,1,0,0,0,0,0,0,0,0,0,1,1,0,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte E[] = {
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
};
byte F[] = {
  0,0,0,0,0,0,1,1,0,0,0,0,1,1,
  0,0,0,0,0,0,1,1,0,0,0,0,1,1,
  0,0,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,0,1,1,1,1,1
};
byte G[] = {
  1,1,1,1,1,1,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte H[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte I[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,0,0,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
byte J[] = {
  1,1,1,1,1,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,0,0,0,0,0,0,0,0,0,
  1,1,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,0,0,1,1
};
byte K[] = {
  1,1,0,0,0,0,0,0,0,1,1,1,0,0,
  0,1,1,0,0,0,0,1,1,1,1,0,0,0,
  0,0,1,1,0,0,1,1,1,0,0,0,0,0,
  0,0,0,1,1,1,1,1,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte L[] = {
  1,1,1,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte M[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,1,1,1,0,
  0,0,0,0,0,0,0,0,0,1,1,1,0,0,
  0,0,0,0,0,0,0,0,0,0,1,1,1,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte N[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,1,1,1,0,0,0,0,0,0,0,0,0,0,
  0,0,0,1,1,1,1,1,1,1,1,0,0,0,
  0,0,0,0,0,0,0,0,0,0,1,1,1,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte O[] = {
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,0,0,0,0,0,0,0,0,0,0,1,1,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0
};
byte P[] = {
  0,0,0,0,0,0,0,0,1,1,1,1,1,0,
  0,0,0,0,0,0,0,1,1,0,0,0,1,1,
  0,0,0,0,0,0,0,1,1,0,0,0,1,1,
  0,0,0,0,0,0,0,1,1,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte Q[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,1,1,1,0,0,1,1,
  0,0,0,0,0,0,0,1,1,0,0,0,1,1,
  0,0,0,0,0,0,0,1,1,0,0,0,1,1,
  0,0,0,0,0,0,0,0,1,1,1,1,1,0
};
byte R[] = {
  1,1,1,0,0,0,0,0,1,1,1,1,1,0,
  0,1,1,1,1,0,0,1,1,0,0,0,1,1,
  0,0,0,1,1,1,0,1,1,0,0,0,1,1,
  0,0,0,0,1,1,1,1,1,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte S[] = {
  1,1,1,1,1,1,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,0,0,0,0,1,1,
  1,1,0,0,0,0,1,1,1,1,1,1,1,1
};
byte T[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,1,1
};
byte U[] = {
  0,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,0,0,0,0,0,0,0,0,0,0,0,0,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,0,0,0,0,0,0,0,0,0,0,0,0,
  0,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte V[] = {
  0,0,0,0,0,0,1,1,1,1,1,1,1,1,
  0,0,1,1,1,1,1,1,1,1,0,0,0,0,
  1,1,1,1,0,0,0,0,0,0,0,0,0,0,
  0,0,1,1,1,1,1,1,1,1,0,0,0,0,
  0,0,0,0,0,0,1,1,1,1,1,1,1,1
};
byte W[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,1,1,1,0,0,0,0,0,0,0,0,0,0,
  0,0,1,1,1,1,0,0,0,0,0,0,0,0,
  0,1,1,1,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte X[] = {
  1,1,1,1,0,0,0,0,0,0,1,1,1,1,
  0,0,0,1,1,1,1,1,1,1,1,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,1,1,1,1,1,1,1,1,0,0,0,
  1,1,1,1,0,0,0,0,0,0,1,1,1,1
};
byte Y[] = {
  0,0,0,0,0,0,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,0,0,0,0,0,0,
  1,0,1,1,0,1,1,1,0,0,0,0,0,0,
  0,0,0,0,1,1,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,1,1,1,1,1,1
};
byte Z[] = {
  1,1,0,0,0,0,0,0,1,1,1,1,1,1,
  1,1,0,0,0,0,0,1,1,1,0,0,1,1,
  1,1,0,0,0,1,1,1,1,0,0,0,1,1,
  1,1,0,0,1,1,1,0,0,0,0,0,1,1,
  1,1,1,1,1,1,0,0,0,0,0,0,1,1
};
byte line[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};
byte line2[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte line3[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte line4[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};
byte PIPI[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,1,1,1,1,1,1,0,0,0,0,0,0,0,
  0,1,1,0,0,1,1,0,0,0,0,0,0,0,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  0,0,0,0,0,0,0,0,0,1,0,0,1,1,
  0,0,0,0,0,0,0,0,0,1,0,0,1,1,
  0,1,1,1,1,1,1,1,1,1,1,1,1,0,
  0,1,1,0,0,1,1,0,0,0,0,0,0,0,
  0,1,1,1,1,1,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1
};

byte Ani1[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,1,1,1,1,0,0,0,0,0,
  0,0,0,0,0,1,1,1,1,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
byte Ani2[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,1,1,1,1,0,0,0,0,0,
  0,0,0,0,1,1,1,1,1,1,0,0,0,0,
  0,0,0,0,1,1,1,1,1,1,0,0,0,0,
  0,0,0,0,0,1,1,1,1,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
byte Ani3[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,1,0,0,1,1,0,0,1,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,1,0,1,1,1,1,0,1,0,0,0,
  0,0,0,1,0,1,1,1,1,0,1,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,1,0,0,1,1,0,0,1,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
byte Ani4[] = {
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,1,0,0,1,1,0,0,1,0,0,0,
  0,0,1,0,1,0,0,0,0,1,0,1,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,1,0,0,0,0,0,0,1,0,0,0,
  0,0,0,1,0,0,0,0,0,0,1,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,1,0,1,0,0,0,0,1,0,1,0,0,
  0,0,0,1,0,0,1,1,0,0,1,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
byte Ani5[] = {
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,1,0,0,1,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,1,0,0,1,1,0,0,1,0,0,0,
  0,0,1,0,0,0,0,0,0,1,0,1,0,0,
  0,1,0,0,0,0,0,0,0,0,0,0,1,0,
  1,0,0,1,0,0,0,0,0,0,1,0,0,1,
  1,0,0,1,0,0,0,0,0,0,1,0,0,1,
  0,1,0,0,0,0,0,0,0,0,0,0,1,0,
  0,0,1,0,1,0,0,0,0,1,0,1,0,0,
  0,0,0,1,0,0,1,1,0,0,1,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,0,0,1,0,0,1,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0
};
byte Ani6[] = {
  0,0,0,0,0,0,1,1,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,1,0,0,0,0,0,0,0,0,1,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  1,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,1,0,0,0,0,0,0,0,0,1,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,1,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,1,1,0,0,0,0,0,0
};


byte* alpha[] = { A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z };
byte* num[] = { NUMBER0,NUMBER1,NUMBER2,NUMBER3,NUMBER4,NUMBER5,NUMBER6,NUMBER7,NUMBER8,NUMBER9 };
byte* ani[] = { Ani1,Ani2,Ani3,Ani4,Ani5,Ani6 };

#include <FastLED.h>
#include <LowPower.h>
#define NUM_LEDS 14
#define DATA_PIN 3
#define TIMEOUT_MS 5000
#define HALLPIN 2
#define NUM_LINES 90
volatile unsigned long millisPerRot = 100;
volatile unsigned long LastRotOccurance = millis();
volatile unsigned long millisPerLine = 10;
volatile bool rotationProcessed = false;

// unsigned long millisPerLetter = 20;  //2 Space 5 Letter 2 Space
CRGB leds[NUM_LEDS];
CRGB bg = CRGB(0, 0, 0);
CRGB fg = CRGB(80, 80, 80);

int bgIndex = 0;
int fgIndex = 0;

int movingLines = 1;
int displayMode = 0;
int displayTimes = 5;
int brightness = 150;

#define BUFF_LEN 100
char buff[BUFF_LEN];
unsigned long startFrame_timeStamp = 0, endFrame_timeStamp = 0;

unsigned long waitLoopTimeStamp = millis();
unsigned long beforeInterruptTimeStamp = millis();

// #define DEBUG

void setup() {
#ifdef DEBUG
  Serial.begin(115200);
#endif
  pinMode(HALLPIN, INPUT);
	FastLED.addLeds<WS2812B, DATA_PIN, GRB>(leds, NUM_LEDS);  // GRB ordering is typical
	millisPerRot = 1000;
	attachInterrupt(0, isr, RISING);
}
void loop() {

  if (millis() - LastRotOccurance > TIMEOUT_MS) {
#ifdef DEBUG
    Serial.println("Shutdown!");
#endif
		printSpaceLine();
		LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
	}

  
  if (rotationProcessed)
		return;
	// Start of Rotation:
	startFrame_timeStamp = millis();


	// Length Of Rotation
  for (int i = 0; i < 6; i++) {
#ifdef DEBUG
    unsigned long printStart = millis();
#endif
		printRawNoAlignment(ani[displayMode], sizeof(Ani1));
		// printSpaceLine();
#ifdef DEBUG
		snprintf(buff, BUFF_LEN, "%lu,", millis() - printStart);
    Serial.print(buff);
#endif
  }
#ifdef DEBUG
  Serial.print(" ");
#endif
	displayMode = (displayMode + 1) % 6;

	rotationProcessed = true;
  endFrame_timeStamp = millis();
  
#ifdef DEBUG
	snprintf(buff, BUFF_LEN, "mspR:%lu LastR:%lu now:%lu, wait?%d, FrameTime:%lu, TimeLeft:%lu, mspL:%lu", millisPerRot, LastRotOccurance, millis(), millis() < LastRotOccurance + millisPerRot - 10, endFrame_timeStamp - startFrame_timeStamp, LastRotOccurance + millisPerRot - millis(),millisPerLine);
	Serial.println(buff);
#endif

	//10ms before next Rotation
	// while (millis() < LastRotOccurance + millisPerRot - 10 && rotationProcessed) {
	// 	;;
	// }

	// snprintf(buff, BUFF_LEN, "end:%lu, predicted Next:%lu, Predicted Left:%lu", millis(), LastRotOccurance + millisPerRot, LastRotOccurance + millisPerRot - millis());
	// Serial.println(buff);

	// snprintf(buff, BUFF_LEN, "mspR:%lu Waited:%lu LastR:%lu now:%lu, wait?%d", millisPerRot, millis() - startFrame_timeStamp, LastRotOccurance, millis(), millis() < LastRotOccurance + millisPerRot - 10);
	// Serial.println(buff);

}


void printSpaceLine() {
	for (int i = 0; i < NUM_LEDS;i++) {
		leds[i] = CRGB(0, 0, 0);
	}
	FastLED.show();
}

void isr() {
	// millisPerRot -= millisPerRot / 3;
  // millisPerRot += (millis() - LastRotOccurance) / 3;
#ifdef DEBUG
  Serial.print("_i_");
#endif
	millisPerRot = millis() - LastRotOccurance;
	LastRotOccurance = millis();
	millisPerLine = millisPerRot / NUM_LINES;  //4 Degree per Line
	rotationProcessed = false;
}

void printLetter(byte letter[]) {
	//Time start and Time to next letter
	unsigned long printStart = millis();
	unsigned long nextLine = printStart + millisPerLine * 2;

	int y;
	//Loop for the 2 space beforehand
	for (y = 0; y < NUM_LEDS; y++) {
		leds[y] = bg;
	}
	FastLED.show();
	while (millis() < nextLine) {
		;
	}

	//Loop for all 5 letter degrees
	for (int x = 0; x < 70;x += NUM_LEDS) {
		for (y = 0; y < NUM_LEDS; y++) {
			if (letter[y + x])
				leds[y] = fg;
			else
				leds[y] = bg;
		}
		FastLED.show();
		nextLine += millisPerLine;
		while (millis() < nextLine) {
			;
		}
	}
	//Loop for the 2 remaining space pixel
	for (y = 0; y < NUM_LEDS; y++) {
		leds[y] = bg;
	}
	FastLED.show();
	nextLine += 2 * millisPerLine;
	while (millis() < nextLine) {
		;
	}
}

void printMovingRaw(byte raw[], int len) {
	//Time start and Time to next letter      //Prints up to 90 Lines with 14 px per line -> 1260px
	unsigned long printStart = millis();
	unsigned long nextLine = printStart + movingLines * millisPerLine;
	movingLines += 3;
	if (movingLines >= NUM_LINES)
		movingLines = 1;
	//If lines is not full, position it at the end, 3/4 of all remaining lines before the image and 1/4 lines before the Magnet
	while (millis() < nextLine) {
		;
	}
	int y;
	//Loop for all lines in raw
	for (int x = 0; x < len;x += NUM_LEDS) {
		//Loop for all pixels in a line
		for (y = 0; y < NUM_LEDS; y++) {
			if (raw[y + x])
				leds[y] = fg;
			else
				leds[y] = bg;
		}
		FastLED.show();
		nextLine += millisPerLine;
		while (millis() < nextLine) {
			;
		}
	}
	//Set following Pixel to background
	for (y = 0; y < NUM_LEDS; y++) {
		leds[y] = bg;
	}
	FastLED.show();
}


void printRaw(byte raw[], int len) {
	//Time start and Time to next letter      //Prints up to 90 Lines with 14 px per line -> 1260px
	unsigned long printStart = millis();
	int flines = NUM_LINES - len / 14; //Gives the number of free lines to move printing
	unsigned long nextLine = printStart + ((float)flines) * 3.0 / 4.0 * millisPerLine;
	//If lines is not full, position it at the end, 3/4 of all remaining lines before the image and 1/4 lines before the Magnet
	while (millis() < nextLine) {
		;
	}
	int y;
	//Loop for all lines in raw
	for (int x = 0; x < len;x += NUM_LEDS) {
		//Loop for all pixels in a line
		for (y = 0; y < NUM_LEDS; y++) {
			if (raw[y + x])
				leds[y] = fg;
			else
				leds[y] = bg;
		}
		FastLED.show();
		nextLine += millisPerLine;
		while (millis() < nextLine) {
			;
		}
	}
	//Set following Pixel to background
	for (y = 0; y < NUM_LEDS; y++) {
		leds[y] = bg;
	}
	FastLED.show();
	//Print the 1/4 free-lines Space after the raw image
	nextLine += ((float)flines) / 4.0 * millisPerLine;
	while (millis() < nextLine) {
		;
	}
}
void printRawNoAlignment(byte raw[], int len) {
	//Time start and Time to next letter      //Prints up to 90 Lines with 14 px per line -> 1260px
	unsigned long startNextLine = millis() + millisPerLine;
	int y;
	// snprintf(buff, BUFF_LEN, "now:%lu,nLine:%lu ", millis(), startNextLine);
	// Serial.print(buff);
	//Loop for all lines in raw
	for (int x = 0; x < len;x += NUM_LEDS) {
		//Loop for all pixels in a line
		for (y = 0; y < NUM_LEDS; y++) {
			if (raw[y + x])
				leds[y] = fg;
			else
				leds[y] = bg;
		}
		// Serial.print("-");
		FastLED.show();
		while (millis() < startNextLine) {
			;
		}
		startNextLine += millisPerLine;
	}
	// Serial.print(" ");
}










// void loop() {


// 	// With 9 Lines per letter its 90 Lines per rotation, so 10 letters per rotation, each Line has 14 Pixel

// 	// EVERY_N_MILLIS(250) {
// 	// 	bgIndex++;
// 	// 	fgIndex += 3;
// 	// 	bg = ColorFromPalette(RainbowColors_p, bgIndex, brightness, LINEARBLEND);
// 	// 	fg = ColorFromPalette(RainbowColors_p, fgIndex, brightness, LINEARBLEND);
//   // }

//   // while (millis() < LastRotOccurance + millisPerRot) {
//   //   snprintf(buff, BUFF_LEN, "loopLeft:%lu", LastRotOccurance + millisPerRot - millis());
//   //   Serial.println(buff);
//   //   delay(100);
//   // }



//   //printMovingRaw(PIPI,sizeof(PIPI));
// 	/*if(displayMode++ < displayTimes){
// 	  printLetter(_);
// 	  printLetter(_);
// 	  printLetter(C);
// 	  printLetter(R);
// 	  printLetter(I);
// 	  printLetter(T);
// 	  printLetter(I);
// 	  printLetter(C);
// 	  printLetter(A);
// 	  printLetter(L);
// 	}else if(displayMode++ < 2* displayTimes){
// 	  printLetter(_);
// 	  printLetter(M);
// 	  printLetter(A);
// 	  printLetter(S);
// 	  printLetter(S);
// 	  printLetter(_);
// 	  printLetter(M);
// 	  printLetter(A);
// 	  printLetter(S);
// 	  printLetter(S);
// 	}else{
// 	  displayMode = 0;
// 	}
// 	*/
// 	// Serial.println();
// 	// Serial.print(" ");
// 	// // for (int i = 0; i < 6; i++) {
// 	// unsigned long printStart = millis();
// 	// printRawNoAlignment(ani[displayMode], sizeof(Ani1));
//   // printSpaceLine();

//   // snprintf(buff, BUFF_LEN, "%lu,", millis() - printStart);
// 	// Serial.print(buff);
// 	// // }
// 	// Serial.print(" ");
// 	// displayMode++;
// 	// if (displayMode > 5)
// 	// 	displayMode = 0;

// 	// if (millis() - LastRotOccurance > TIMEOUT_MS) {
// 	// 	Serial.println("Shutdown!");
// 	// 	printSpaceLine();
// 	// 	LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
// 	// }

//   // beforeInterruptTimeStamp = millis();
//   // // Wait for Interrupt
//   // while (millis() < LastRotOccurance) {
//   //   ;;
//   // }


//   if (rotationProcessed)
//     return;

//   // Start of Rotation:

//   snprintf(buff, BUFF_LEN, "start:%lu", millis());
//   Serial.println(buff);

//   startFrame_timeStamp = millis();

//   // Length Of Rotation
//   while (millis() < LastRotOccurance + millisPerRot - 10) {
//     ;;
//   }


//   //10ms before next Rotation

//   snprintf(buff, BUFF_LEN, "end:%lu, predicted Next:%lu, Predicted Left:%lu", millis(), LastRotOccurance + millisPerRot, LastRotOccurance + millisPerRot - millis());
//   Serial.println(buff);

//   snprintf(buff, BUFF_LEN, "mspR:%lu Waited:%lu LastR:%lu now:%lu, wait?%d", millisPerRot, millis() - startFrame_timeStamp, LastRotOccurance, millis(), millis() < LastRotOccurance + millisPerRot - 10);
//   Serial.println(buff);
//   rotationProcessed = true;


// }